"Hello, welcome to CS H2, H3, Network Security. My name is Professor Philip Mac, and today we are discussing lecture five, which is on cryptography. This lecture is little different from our other ones. This is a video only lecture pre recorded, so we can do things a little bit differently. First of all, points during the lecture, I'll ask you to pause the video so you do the exercises yourself. This week, we will not be collecting and exercises. So any exercises that we do is purely for your own benefit. Spa, or the expectation is that you have time to review the lectures before the class. So if you have not done so yet, please pause the video now, take some time and lectures and make sure that you understand it and come back to this video where we will discuss some items in more details. So at this point, I expect that you already looked to the lecture slides already. So on cryptography, there's really four main things that we talk about. We talk about basic cryptography, some history, some definitions. We talk about symmetric key cryptography, which we don't go into 2a, she tells about we talk about public key cryptography. And then we start talked about message integrity and how signatures are created. Cryptography. Some definitions that we used in this class that you will need to know is plain text and cipher text. Plain text is on encrypted text. Cipher text is text that is already encrypted. Meaning unless you have the key or you know how to read it, you aren't able to visit. The actual definition of cipher texts is it is unreadable, encrypted text that unless an authorized user is, has ability to read it, cannot read it. And cryptography generally has two components, an algorithm and a key. For example, AES. Aes is probably one of the most widely used encryption algorithms, symmetric encryption algorithms out there right now. And it has two main components, an algorithm and a key. And the difference between these two components is that the algorithm for AES, it's open. Anyone can review it, anyone can implemented. Now, I don't recommend that you implemented, but it is open and available. The key, however, is kept secret. So as long as you have one of these components as secret, it doesn't matter if you have the other component. In other words, AES is an open standard. Opens probably the wrong word. Aes is a standard that anyone can review. Anyone can look at the code and then we can look at the implementation. And then we can look at the algorithm. Does not matter as long as you don't have the key, you can now decrypt ciphertext. That's really the really important part of it. And that's how a lot of these incursion items are made. The algorithm is open. Anyone can see Darwin, but the key is kept secret. So without one of these components, you cannot decrypt the cipher text. When the earliest ciphers is called a Julius Caesar cipher. So in this example, Julius Caesar has this key value. Key value in this case is shift plus three. Shift, right? Three plus three. And you can see how it works here is that there just in cry inscribe texts using a chef plus three. So for example, if someone wants to seek the encrypt overheard, hello, hello will get turned in to h becomes K, e becomes h, l becomes o that the of the second l, And then o becomes R. So if I want to encrypt hello using Julius Caesar cipher and the secret key, secret key is plus three, right? Shift three, that it gets transcribed into K, h 00, r as hello. And two decrypted, you go the opposite way. How do we know that cryptography is good? How do we know AS it's good? And that's, that's a really hard process. And really the only good way is it requires time. Like AES has been out for 15 years, right? There's some things we know about it. Sometimes we don't. But it's been pretty good for 15 years, right? Aes has three key sizes. 192256 bit size, right? So AES algorithm is open. You can choose to use three different sizes, right? 128 bit key, 92 per key to 56-bit key, right? And this is, it's a requirement by the US government because they wanted a different standard for used for confidential information, sequence information and top-secret information. That's why we have 1-20 a1 and a2 and to 56-bit keys. Over the last 15 years, larvae search has been debated JS, and they find interesting things like, for example, 192, but the algorithm does not work very well. So if you use a 192 bit key, it turns out that you have less security to 1-20, 8-bit, just some things that you learn over time. So therefore, that's one of the reasons why there is no reason to use 192 bit keys for ESA, yes. Comes in 128 bit or two 56-bit, R2, 56-bit BY a tiny bit more secure than what 28, but, but minority to don't use the and it's even less secure than 128, right? And these are things that we only learn over time. So in order to find out whether an argument is good or not, it just requires time at feast search, knowing knowing that if you researched what AES and you find a vulnerability, nay, yes. You become famous and, and I hope rich as well. World War one, Zimmerman telegram, one of the first uses of cryptography and this type of photography, you notice that in this telegram, there's a bunch of numbers on it. These numbers represent a word, right? And that's it, right? So they have a secret book and each number is associated with a word. So essentially, writing a letter here, accept day transcribing itself a word, it turns into a number instead. And these things were eventually broken, right? Because they have a couple of copies of it. You start to realize There's only a certain number of words they use and the times. And you're able to figure it out. Also, if the accident to the ever release a copy of the plain text and cipher texts, you essentially lose the key as well. So that's really important, right? So one way that this was broken by some other documents, not this one. That is a telegram that costs were the nicest enter World War one. But that other documents had a ciphertext, which is this document here. Any plain text was revealed. And from there they were able to make comparisons and find that, well, you know, that this particular number is related to this word. And because of that, some of these technocrats were broken. And as you break them becomes easier and easier to break them over time. So that's one really important factor is that if you have the plain text and you have to side with both of them, you can use that to try to break the key, right? As modern cryptography works exactly the same way. So let's say you have using a as an AES, AES encryption. Really good, right? Aes-256 split. With current technology. You need to go to the end of the universe, 13 billion years from now before you're able to break it really is. But if you have the plaintext and the ciphertext, you can break it very easily, right? Where we'll to Enigma. Enigma is a really, really interesting encryption machine. And because of how sophisticated it was, it took a really long time to break the encryption. How it works is that it has a number of rhoptries here. And these are these wheels, right? This line over here, that's a wheel that's gets inserted at a later verse, five wheels. So each time a letter is type, one of these wheels changes. Because the real changes. Whoa, encryption algorithm for that particular key gets the gets changed. And we're gonna take a closer look at that as well in this class. Why would you use to cryptography? A couple of reasons. First, confidentiality, right? So only the authorized users are able to veto messages. Integrity, right? Making sure that a message does not get changed during transit. For example, I send a message to you. I want to make sure that the integrity of my message does not change between became. B to u. And right now there isn't much integrity, right? Because I don't have a key signature. We deciding my messages. So if there was a malicious actor that's either compromise my computer, your computer on the network, potentially. Any messages I said Who can be altered, authentication as an verifying who I am or be aware of who you are, what I send or receive messages from your non repudiation. Non-repudiation. There are two types of non-repudiation, right? First type of non-repudiation is ensuring that I set the message. That I can say, that you can prove that I actually sent the message. So for example, I said, journalists are saying quiz at this table. Right? Then you come back to me and say, Professor Mack, did you send this message? And I say, no, I didn't send the message. Proved I send this message out, repudiation of origin, right? But if I can prove whether you can prove or not the ice at the message. Right, than this temporal non-repudiation of time. That is, I set the message, but when I send this message, I maybe I set the message, say, free pizza for everyone today. And then you come to me and say professor back, you said I will gets free pizza. And it's a way that no, that was for last semester's class. Last semester gets free pizza, prove to me that I set this message today and not six months ago, right? So there's two types of non-repudiation, right? Not reputation of origin and reputation of time, right? So there's two factors here. Some terms that we use, W's a lot already, Alice, Bob, and Judy, the intruder. So in this example, Alice and Bob were talking to each other and 2D is the intruder who wants to break. So when we are using cryptography, we like to use symbols to designate some things. So for example, the letter M, We usually use that to designate the plain text message. M stands for Message plain text. And k is key. So in this case, we say key, right? So M is plain text message, CA is key. So we say K sub a M, We say the message M is be encrypted by key a, right? That's what K sub a M stands for. And here in this example, we're saying message m is encrypted by K sub a, and then is also encrypted by K sub B. In this particular example, K_a and K_b are some Asymmetric algorithms, meaning you use one key to encrypt, used the other key to decrypt. So this makes sense that the plaintext message is encrypted using a key a, and then encrypt it using key B or decrypted. But it's obvious what this means here is the same as. So that's what that means here. Another algorithm, basic algorithm is called the simple encryption scheme. And this is extremely simple. You might see crossword puzzles or estimate that the New York Times with this type of and how it works is that you have to pay tax and you have a encrypted tags. And you used as to, as your algorithm to perform encryption or decryption. So in this example, let's say I have the plain texts. Bob, I love you, Alice. The encrypted text. This is simply a substitution of one letter for letter. So for example, B, V is V. B is, ooh, what's going on here? Well, I think this example is a poor example. But the intended, that way for this to work is that Bob, I love you. Alice turned into B goes to N, o goes to K, and so on. So there's something wrong with this example. In this lecture. We have exercises, but there will be collected. So at this point on the next slide. Next slide, if you want to do the example by herself before we do a class, you pause the video when I turn it to the next slide. And then do the exercise yourself and then unpause the video when you're done. So for example, I go to the next slide, I have fixed exercise. At this point. You expect to do it yourself. And when you're done, you pause the video. So pause the video now. And when you're done, you pause the video. Right? So exercise number one, these not being collected. So you want to Julius Caesar Cipher left shift, left shift, right? So what this, then, what this means is that a go, the letter a will go to with an X, and B goes to y, c goes to Z, and d goes to a, and so on, right? And mechanical figured this out, but Whenever p is, you take three characters before you get that as the encrypted text. How can you remember that? Well, it's pretty simple. Right? Left shift. Left shift three, negative three. So you take your current letter and u minus three off it. So in the example in the class, we had a right shift, three plus three. So in that case, plus three, a will go to d, and b will go to e and so on. So in this case, p, you take the logs before that, o, L, y, take dwellers before all of these and that you get the encrypted text. A simple encryption scheme, but the key here, right, so this is incurred from top to bottom part right here. This is a little tricky, right? So this says be crip and don't get confused. And when you decrypt it, you go from bottom up. So in this case, a, a is H, c is e, g is L, G, L, K is o. So the original, the original plaintext messages, Hello. They'll get this decrypt confused, right? So these questions, you CaesarCipher left shift to encrypt. It could say decrypt any 2D opposites, don't get confused. That's really, really simple to get confused so that another encryption scheme is called the poly alphabetical encryption scheme. And the poly alphabetic encryption scheme is a substitution cipher. But it changes for every time you go to the next letter. So in this example, you have a table of standard table. This ability to memorize where it goes from a to C and a to Z. A to Z as a shift, what everytime one side, one axis is the key and the other side is plain text. Though. To go further, let's just go right into the example. So in this example, we have the plain texas NYU and the key is concept called as communication security. And, and I choose one axis as my plaintext, at one axis as my k. So n, n is over here, I ended over here. C is over here. Therefore, my cipher texts. This is p. P. So the first letter is key. Like a letter. It's why. And so I find y here, I find o here. And my ciphertexts is what? I think it's l. M is m, So it's p m. P m at the last letter is U. So what would that be? So let me phi u, u is here, and m is here. The cipher text is say, G, G, G, G, So p, m t g. So what does this mean? You have a plain text and you can think of it as something similar to the simple substitution cipher, right? You take one letter, you substitute a to another. But every k, every time we go to next letter, changed her next key. The key changes every time. So for n, you use the key for C, for why use the key for o. And for you use the key for m in order to encrypt this into P, G, P, T. Next step is we want to decrypt it. Alright, so let's decrypted text is p, g. Let me clear this out. So it was MG, TMG. So ciphertexts is P, m, g, and the plain text is NYU's. So we'll pretend that we don't know that right now. It's a ciphertext is P and G, C0 is concept. We're going to decrypt it. So the middle part, the middle part of it is the ciphertext. Ciphertext is PMT, the key concept. So the middle part yet remember, is a ciphertext. So we pick one axis as the key and the ciphertext. So the middle part. This table is the ciphertexts. Okay? So then we take a key, that's the key is C. In this case, we pick C. And then within the ciphertext you look for p. So we look for p here. This is p. Therefore C and P. The plain text here is n. So c and p goes to n. So plain text is n, letter key o m. So the key is o, q0, o ciphertext is m, ciphertexts is m, right? Therefore, O, M, the plain texts is y. As expected. As expected. Third letter, m And ciphertext c0 is M. Ciphertext is g, g here. And therefore the plane taxes you as expected. So key, second ciphertext PFGE decrypts into N by expected. So now we're gonna have these exercises. Please. Your ticket to yourself. When I moved to the next slide, please pause the video. Do the exercises when you're done. So similar exercise as we did before. You encrypt a plaintext with the key. So we go to exactly the same thing we did before. Plaintexts keys is L. So I'll pick one axis as a plaintext, one axis, SDK, plaintext H, H, and L, And I get S, S. So I get E over here. Don't get confused here. L over here. Eight next one, e and o. And therefore V S, S, S, S. Now we ran off key, so we use the next one. So it becomes o again. Right, so l goes to o as time becomes L. L is over here again, and L is over here. So we get l n l, we encrypt it. We get w, right? So the answer is es s w. So encrypted text is S, S w. As SW. Next slide. Pause the video, go to the next slide and decrypt as S w is a different one. Example. Alright, so often and resume the video. So let's say the ciphertext is a, b, c, d, e. So remember that the ciphertext is in the middle of cipher text is in the middle. Part, a, B, C, D, E, I pick D on one side. Then I find a. K is over here. Therefore. Therefore, the first letter is X, X, B, and D. So the ciphertext we try to look for in the middle key is E, E over here. And we look for B, that's also x. So as x, x c encrypts to decrypt to use d. So super sexy key is D again. So d. We look for c over here, and therefore z. So the plaintext is plaintext messages x, x, z, right? And just to make sure you do it right, you should be touching encrypted. You should be able to get a, B, C, for example, as well. So that was, that was an example of how a polygraph Diego encryption works are VGS, VGS, and this is exactly how it works, right? So my machine had to be in this version, but it has five different wheels. And you can think of each of these views as a poly alphabetical encryption. Algorithm, except each wheel is its own hardware cipher. So you have five vertices. You can imagine going through this table five times intellectually. What letter, right? Imagine going do this table five times to encrypt one letter, and that's what we'll write. So each wheel is a table just like this, right? It's different. And when a key is pressed on the Enigma machine, it goes through this table five times and outcome spits out the final ciphertext. So imagine how hard it is for something like this to decrypt. And, and it was very hard to encrypt that bring them perfect substitution cipher. So let's say you want to find the perfect, absolutely perfect encryption scheme. But, you know, that's, that's pretty hard, right? That is, that's very hard. And the reason for that is that for it to be perfect, you don't want to reuse anything ever, right? There's no reuse and your data has become completely random. It ought to generate something like this. So varName is numbness is one time pad, right? One time pad as an you encrypt something one time, Addie using that one time pad, and you never use it again. So for example, you can use a book to do this. You take a book and your book is completely made-up, complete random data. You encrypt something with your book as a key one time and then decrypted and you never used to saint book again. You never use it again, right? And this book comes from data. Data you fill. This book comes from some effort that's completely random. And what's random in the world, right? Radiation does pretty much Monteverdi examples radiation. And that's really hard, right? Because now you have this book carry around with you. And that was, this is what makes encryption so hard. If you use truly random data, which you could use one time, right? And the one time pad, we call it. Now you have to share this one time pad. And back in the good old days, maybe 3040 years ago. You have diplomats. They'll actually take this actual book with thump with diplomatic immunity and carry it to the bag to know anywhere they want and what they want to encrypt and decrypt something. They used the one time pad, do that today. That's just really, really hard to do. Or the breaking crucial schemes is three ways. Ciphertext only attacks, known plaintext attack, and a chosen plaintext attack. These are things that you need to be aware of. These definitions need to understand. So if you don't understand these definitions, make sure you Google Reader VP, Wikipedia article and try to understand more. Composition, computational time effort, same time. Thida decides types of cryptography. In this class, we talk about three types of cartography. The 1B, although and easy to understand is called symmetric key cryptography. That is, use the same key for encryption and decryption. Same key encryption decryption. Public-key cryptography. That is the NSString algorithm where you have one key, we can separate the two parts, K_a and K_b, which we also called public and private key, AMQP or public or private. And then had a very interesting property where we take k and you encrypt something. You need to use key B in order to decrypt it, right? You cannot decrypt a key. So you encrypt with key a. You cannot decrypt with key. You must huge key in order to decrypt it, right? And same thing for other way, gap KB. If you encrypting the user key b, you must use key a, encrypted with a public key cryptography. And if I said did not make sense to you, please take your time and do some research that I have some links in the reading materials that go over this in more details. And hash functions has function says consider a one time function. As an, you take something, it goes through a hash function and you get a smaller representation of it. For example, war and peace, right? That's a, that's a pretty long book. You'd pick one piece and you put it through an MD5 hash, right? No matter what the size pieces, you'll have a fairly unique 128-bit representation of that book. If in one piece, I'll go change one character, one character. And I had been a letter character. I change one character in War and Peace. And I do the md5 hash again, that 128-bit representations of warranties will be completely different. And that's how hash functions work. Janet, characteristics of good ciphers. This is not tested on Sunday night. You should know. Confusion and diffusion. Confusion and diffusion are measures of how hard it is to break cryptography. Confusion. And cryptography has two parts. The CKY algorithm, confusion. You change one bit in the key. The ciphertext that comes out of it, completely different. So you take some plain text encrypted with a key, you change one bit of Turkey. The entire resulting ciphertext is completely change, like it changed all over the place. Right? This is not a small mapping. We changed one bit to keep, the whole thing changes. The whole ciphertext changes diffusion. You change one bit in the plaintext. An encrypted. Your cipher text to be completely different from before, right? Is just localized changes in it. The whole thing changes its confusion and diffusion. You change one bit of the key. The whole ciphertext changes. Diffusion. You change one bit of the plaintext, the ciphertext changes. Symmetric key cryptography. Symmetric-key cryptography is when you use the same key for encryption and decryption. The challenges with that is that you have to share the key somehow. Like for example, when an online class right now, right? More like they're not, I probably won't see any of you face-to-face ever. Right? Though. If I have any publics, keep speaking engagements at NYU. I'll let you know. Johnny Depp. In order for me to encrypt something to send to you, I need to share the key with you. And that's really hard. That's really hard because we don't see each other. How to I securely, in a secure manner. Cynic TDU. That's really, really hard to do. A symmetric key algorithm by cryptography. Same key encryption. Decryption is two symmetric algorithms, stream ciphers and block ciphers. Stream ciphers. We'll talk later in this class, block ciphers we will talk today. Block ciphers is your very traditional method. It's the most popular one day. Block ciphers include AES. Aes is a block cipher is how block ciphers work. Aes, for example, a is a 128 bit block size cipher. No matter what size that you try to encrypt something again, it has to break it into full 128 bit chunks. And if your plain text message isn't in the order of 128 bits and it's the pad it to 128 bits. So let's say you're trying to encrypt something that's only 5650 bits, ASPs to pad it all the way to 128 bits. In order to encrypted. It only works in 128 bit block sizes. In this example here, we are talking about block sizes of three bits. That's easy to understand, three bit sizes. So let's say you're a 3-bit sizes are this. And if you have only three bits, you have a possibility to one-on-one. And it's easy to understand in a table that if I have 000, my output is 1-1-0, right? In this example, right at this, in this part, this input and output table. That is by symmetric algorithm and key. So this thing is algorithm and key at the same time. On the next slide we have an exercise. Next slide, you can pause it and try to work on it yourself. And then when you're satisfied, you unpause the video. In this case, if the plain texts is 0101100011111 is the ciphertext block cipher. Here, we're using a block cipher. So you have to break this into three bit blocks, right? The all broke it up into three bit blocks. Otherwise it does not work properly. Three bits. And what do you get? You get 010, you get 101, then you get 110000001111111, you get 001. So this is your basic block cipher. This is essentially how any block cipher works. Like AES. Aes works exactly the same way that you don't use an actual tape was an algorithm that goes from him. But to the output is exactly the same thing. Except AES is the algorithm that translates the input output. Exactly how it works. Block ciphers are not just three bits in size is three bits. Block ciphers can be pretty large, right? Yes, 128 bits, that's pretty large. So you can do it in a table like we were talking about. We have to do with it some sort of algorithm. And that algorithm that translates for input-output, that's AS right. That's basically the algorithm, how it works. This is a, we are going to miss that one. But block ciphers more or less work exactly the same way, right? And this is not a split, it works exactly the same way anyways. So and not 64-bit, but essentially in this example you have 64-bit input. It gets broken up into a number of bits of separate blocks. The blocks go through a secret algorithm called a substitution table. Now, the substitution table is not secret, but the strength of by any symmetric algorithm works. Because of this substitution table. Like I substituted. It gets put back together and it gets scrambled around. And it does it again, right? Something like 101216 times or whatever it is. A number of times. You go to a number of times and then you get your, you get your cipher text. This is how a Christian asymmetric encryption, symmetric block encryption algorithm box. You have input, you will get broken up into smaller sizes, goes through substitution table, gets mixed together and do again. The strength of pretty much any block ciphers is the substitution table here. Substitution table is kind of like a one-way function, right? Kind of because you see that is 8-bit goes to shun table, comes out without the proper key. You cannot go backwards, right? That's the whole point of a block cipher. You don't have the proper key. You cannot go backwards to this process, right? The key January's substitution table and a substitution table. And this whole is built in such a way that you just can't go backwards key, or it's very, very hard to do it. Let's say you encrypt a really large file, right? And really larger, let's say 512 bits. The AES block size is 128 bits. So that means if you're encrypting a yes and you try to encrypt by 512 bit file, you need to separate into multiple blocks. So 512 bits gets broken up into four blocks, encrypted four blocks, then you get an encrypted payload. That message encrypted, getting credit box. And now you have your message. The problem like what if, what if all these blocks are exactly the same thing? What if blocks 1234 is actually exactly the same? You take it, you encrypt it, and now you have to 12-bit message, but is actually made of the same message over and over again. Right? So that's one problem with block ciphers, right? If you have repeated data in that, you can have a repeated solution as well. So this 500 cockpit message is really just these four blocks again, four times. Therefore, we have another concept called Block Chaining. In this case, we talk about cipher, cipher block chaining. Cipher block chaining attempts to make it so that if the blocks are exactly the same, they don't have the exact same results. And what's cipher block chaining does is that it takes the result of one block and mixes in the data with the second block. So that the second block, even if the input is exactly the same, it will be exactly the same. To go into it. I prefer to just take an example. So this is a diagram of how cipher block chaining works. You have your plain text message. I see the plaintext message on top. And it shows the plain text comes again. And it goes to the encryption algorithm. But it takes something to mix it in with the plain text, so it will be exactly the same. To do this, it uses a concept called an initialization vector, which is a non secret thing that mixes the first item to propagate to the rest of blocks. Over here after decryption. In this example, what is a ciphertext for IV? Right? So the first thing I do is I'll take this and break them into multiple blocks. Three blocks here, 001001001. Plane tax entering from over here. Plaintext is 001 and v is also 001. Alright, so the first thing it does is this diagram here. The IV XOR with the plain text is usual one. And what do we get from that? 0 or 0 is 00, OR 0 is 01 x or one is one. Right? Then you take an encrypted. So Zuo Zhuan gets encrypted into 1.1.1, actually reveal x or x or 0001, 00110101. So an XOR 00 is 01110, is 1110, is 0. So we have 0000000 and that becomes a becomes 000000 encrypted, you get 110, you get ciphertexts. 110, right? So he just follow the lines here. 110110 goes over here. Take 1-1-0. Put over here. Now I get 01, x or 1-1-0. And from there I get 111. All right, take one-on-one and I encrypt. At 000000, I follow line Xianzu goes to here, goes here, 010, I get 001001. I take one encrypted, I get 111. So the cipher text for this is 11000111. Fairly straightforward. And the real key thing to note here is that a normal encryption like you did before, plain text encrypted ciphertext. But CBC cipher block, cipher CPC. And adds a little something just so that if you get the same thing being created multiple times, you won't have the exact same answer every time. That's TPC is how CBC works. A pause the video and next example, do-it-yourself. Here. So encrypt this preposition. These red plain text is 100, 10112121. K initialization vector is 0. Okay? So 01100, and that becomes 101. You encrypt one-on-one and you get 010010. You get 1111100000. You follow the line, you move it over here. K 1110, you get one-on-one. One-on-one, you decrypt. The cipher text is non-zero. Zuo. Zuo. Fairly straightforward. Just follow the diagram. Now. Let's say you don't by default diagram, you prefer to do it mathematically. And the algorithm is there too, but it's not a slide. But simply by looking at this, I can develop the algorithm in order to do this. Let's see. Let's say the ciphertext one. So ciphertexts one, cipher text block one goes with it, IV, XOR, plain text. And then you encrypt the whole thing. That's x1. So ciphertext b here is the product of the IV XOR plain text and you encrypt that. There you go. That's ciphertext, XOR plaintext. Now, let's see. Ciphertexts x2 equals, so ciphertext, ciphertext T2 goes plaintext into ciphertext. And then you encrypt the whole thing. So again, ciphertext x2, x2 is this one is the encryption of the Tx2 and subtext F1. And then x3 equals X3 equals ciphertext to X or plain text three. So plaintext, ciphertext to encrypt the whole thing. So if you prefer to see the algorithm rather than looking at the pictorial method, does exactly the same thing. So I have exactly the same thing in two ways. How did do it using an algorithm or using a pictorial? Personally, I like to look at the pictures, but it's something that you should need to know any ways, right? So this is C, B, C, and a are the CBC is we use anymore. It's too simplistic. There's lots of weaknesses and it just really not something that we use anymore. But essentially they are more or less almost exactly the same. There are different ways that you fixed that they are together to get different results. But that's the purpose of CBC. Just so you encrypt the same plain text, you don't get the same cipher text every time. Pause here for the next exercise. Exercise number three, be. Previous answer. Okay, so I'm going to skip this one in this class. You should be able to get it by yourself. The AES symmetric key DES, DES is our old standard. We don't use it anymore. Be pretty much all move to AES today. Yesterday. Public key cryptography. Key, or symmetric key cryptography, is the algorithm that's fairly interesting, where you use one key to encrypt and a different key to decrypt the not different. They are mathematically connected to each other to get the difference. In any way. They're just connected to each other. Right? And it's just really interesting properties like public key cryptography. This is the purpose that essentially the whole internet works. Like. You can go to Amazon.com and buy something using your credit card. And you have a structure like even though you never met Amazon to get some secret key with them. That's how public key cryptography works. That's what enables the whole Internet. Two works. Having TA encrypt something requires keep beat decrypted. If ki be encrypt something, you require a team. Before we move on to the lesser cost we need, talk about modular arithmetic and some simple ways to calculate fast module arithmetic. For those of you in computer science or physics, this should be fairly simple for you. But for those you have not. I'm gonna go to this in a little bit of detail. Specifically, there's only one that I really care about in this slide is this one over here. And this is a property where a times b mod n. It goes a mod n times b mod n. And you take the whole thing and do a mod N on it. And that's the appropriate that we're really, really interested in this class. So his example, but 70 to 79. And you try to do that with our calculator. Like how would you do that? And we use this property over here in order to do it. So let's take an example here. So instead of doing 1776 and E-Mart line, I'm gonna do what's seven? Mod 97? That's seven. But next up is, can we do seven squared mod nine? And what's 17 squared? That's 49 by nine, right? But I'm going to use this property over here, right? Because seven squared, but that's actually seven times seven mod nine. So you see I'm in the proper format to use this formula over here. And if I just follow the formula, I'm just following the formula here. I get seven mod nine times seven mod nine. The whole day and night. So I'm just following this formula here. A b mod n equals n times b mod N mod N of it. But I just follow the formula here. And the reason that this, we do that is because here, the seven mod nine, we know that seven mod 97 mod nine is seven, right? So this is actually equivalent of this is seven times seven mod C. That's right because it's exactly the same. So seven times seven is 49999. I know you say, why do you do this? We see that nine is right for you. For next step, seven squared multiplied. Now, seven raised to d. Seven raised format 97 Teresa, format line. That's the equivalent of seven squared times seven squared mod nine. And now in this, in the proper format to use this formula. And it goes seven squared, seven squared, 97 squared mod 99, right? So I just follow the formula. I follow the formula here, right? And what do I get? From here? I get n squared. Nine is seven squared is four. So this is actually 44 mod nine. And so what's that for? For about nine dots, 1609. That equals seven. Alright, so actually it's not too bad here. Not as bad as you think it would be. So next step. Next step, I want seven raised to eight mod nine, right? Seven races follow this formula as follow it. And I get, I get seven wastes reformat nine times seven raised, four mod 99. I'll write out one last time, right? That's seven raised to four by 97, raised to four mod nine. Take the whole deign to about nine. What's the format formaldehyde that's separate wasted a format nine is seven times seven mod nine. Was that 49? What's 49? That's four. So 78 is four. So it's actually not so bad, is it? So next step, raised 16 by nine. That is 69, and that equals seven. So both my goal, my goal is to get seven races, 79. Alright? So now seven raised 17 bar nine. And that equals 79. So, oops, Alright, so that's faded away. Seven races. 70 my lines, a current of seven raised to the one times seven, raised, 16 MOD seven raised to 77, raised to the one times seven races 169. So that is equivalent of seven mod nine times seven raised 1699 equal to 79 is seven. So this is seven times seven races. 69 is also seven. So you get 494994. So what is 171779? That's four digit answer. Right? Now, while we do some pretty complicated math, let's double check our work, right? We should double check our work here. Just in case. So I like to use a website called Wolfram Alpha. Let me share my screen here. Right? So rho from alpha, alpha and I type in what was it again, it's seven races, 77, races 179. And answer is four. The answer is four. So we are correct, right? So next example. What seven to 97911, same thing. Bod goes 77 squared, nine, it goes seven times seven mod nine equals 49 mod nine equals four. We raised four mod nine. It goes 169 equals seven. So seven raised for raiser for about nine, it goes 49, but nine it goes for seven, raised to 5979 times seven. I didn't. 7878 is 77. Raised. 99 goes 79 times seven, raised to the eighth. Ninth. Line, goes, goes seven mod 97 times seven is seven by nine. It goes 49 mod nine goes for price target answers for any check your answer from alpha to make sure he didn't make any silly mistakes, right? You need to know this for the exam. Rsa. So in this class and on your midterm exam, you get a problem in which you generate some RSA keys as well. And note that the RSA keys, the key a and key P, are mathematically linked to each other. I'm going to go through a process of calculate them for this class. So there's a five-step FAR, it's require five-step method. But to generate RSA key, you first start with two very large prime numbers, p and q, in this case, to very large prime numbers. And what really large prime number means, it's at least one or 24 bits. So when you hear we say RSA, RSA today needs to be at least 2048 bits in size. What they mean is the n value. So you have to compute n as next step at the end value is p times q. And then what the end value to be two or 48 bits in size. So in general, that means p and q needs to be to avoid bits as well in order to generate and that's about four bits. Lets us and value. Then you calculate the phi value to phi value is p minus one times q minus one. Then from here you find the encryption key and decryption key, ie. The two properties that need to be aware of. The first poppy is that E is less than fi. And second is e and v are relatively prime. If this is concept has nofollow overview book over in some more detail. Then you have to choose the value d. H is the value D, which is the decryption key d. And after you figure all that out, your public key is n comma e, and the private key is n comma D. And if this was a little confusing to you, that's okay. Let's go through an example for that. To do that. So example, I pick two large prime numbers. P goes five, cubic or 70. I know they're not large prime numbers. And we're going to run some popsicles, large prime numbers, but we'll give it a shot and always find the symptoms following the five steps here, right? One, choose two prime numbers, p and q, k. So here I have P equals five. Q0 goes seven. Right? Step to compute n and phi. So n is p times p times q is five times seven. That's 35 AD phi is phi p minus one, q minus one. So that's five minus 17 minus one. And that, it goes four times 624, right? So in other words, I have an IT goes 35 and I have. Fee goes 24. Right. So here's where I am now. Now, he's probably one of the hardest parts. Choose e such that e is less than phi. So e is less than 24 and has no covered factors were phi. So that is e and v are relatively prime. So this is two factors here. We need to know that it choose e such that e is less than 24, is less than fi. And e and phi are relatively prime. And that means no common factors aside from one and itself. Such relatively prime. And in this class, and in the computer, they actually just use a trial and error method, defined it. Right. So that's one reason why January R's key Islam, he, they do trial and error. We, since really small numbers in this class, which is try to figure out. All right, so let's just try a few values here. So possible, so possible values of e like to, like to be. And now I can solve freshness. Can number to be E. And it's no. No because two is a common factor in 24. So two is a factor in 24. So two cannot be about the number three, the candidate number three. Number three B, E. And it's no, right? No, because three is a common factor of 243 divides into 24. Right. So it can't be, that can't be it. How about for like four b? A can for b0 says no, no for can't be. Because four divides. Four has two as a factor and two divides 24. No, two is a factor of 24. Let me just move this slide. A little bit easier. So five, is it phi two is 525, any common factors? So yes, five. So five is less than 24524, have no common factors. So five is a possible value of v. So five is a possible value of a, right? So about six. How about 66? Now, right? Because of two. So actually all even numbers are not going to work. Like all even numbers won't work. So we'll just ignore all the even numbers. 77, yes, right, because seven is less than 247, 24 dough doesn't have any common factors. So yes, seven is a possible value of E 89. Now because of three because of 310111213? Yes. 15 no. Right. Because of 317? Yes. 18-19? Yes. Twenty one. Twenty two, twenty three. So there is all the possible so I've noted all the possible values of 0s here, right? Right, these are all the possible values of e. And we can do that because we talk about really small numbers. So I choose one as e. It depends on what is it, but the problem sets, but choose e equals five based on this case. Now the next step is or encryption key. So this is our encryption value R. Now we have to choose D, which is the decryption value. Try to choose the Godfather formula. Ed mod phi equals one, where you just follow the formula and find something that fits this value. So ED BAD, phi equals one. And we choose a to be five. So five, the BOD. Fi is 24 equals one. So there are a number of ways to figure this out. If you take the topography, you could use an algorithm to use a formula to figure this out. In our class. We are just to try and error will be made simple enough so you can actually do that. Let me move this slide. So 5D habit. How about D equals one? Right? Does that work? Right? So you trust, try it five to the one, mod 24 does a Eco 1524. It goes one. Right? Now. Our D equals two into five types to bar 24 equals one, right? So five times two is 1024, because one, d equals 35 times 324 equals one. No, right? D equals 45 raised to four mod 24 equals one. T equals 55 times 524. Does that goes yes. Right? So 25-35, B24 equals one. So yes, so d equals five. So if e is five, D is five. But now your public key is our N, e and d. So a public key is n, e, n is 20355, and your private key is 35, and d is five. So this is your public key. Private key. So your public key is 355 and the associated private key is 355. So in other words, these two keys are linked to each other. Mathematically, you encrypt with one, we need the other one. This is a special case, right? This is not supposed to be the same. Your public key and private key should not be the same. So you actually cannot use these values. But these things happen because our values are so small, you have these weird artifacts occur because of it. And because we used the 24, which is a very special number, these things happen in real life. You are going to check to see whether the public key and private key are the same and they cannot be the same. But this is an example, right? They cannot be the same because the adversary will be very easily. They would just try to key decrypts it. Properly. Next step, right? Now we have e equals five and d equals five. N equals 35. We can, we can encrypt stuff, a decrypt stuff. So ciphertexts, ghost message raised to the e mod n. That's how you encrypt stuff using RSA. This, it goes m, raise to d. What I do here. Oh, I see what happened here. It's a little messed up. So this goes m raised to e, which is five mod 35. So if I want to encrypt something, let's say I use it a very simple number like m. It goes message equals two. Plaintext message she goes to, I just type the same as two raised to five by 35. So I want to encrypt something I do to register five mod 35 watts to raise five mod 35. While I do it very simply. Two raised to the five mod 35 to 35 equals 245. It goes for wood is not that helpful. 1635. Ghosts 16 is not helpful. So this is hard. So 16 times 16, I'm just going to cheat this time. I have, I have Wolfram Alpha here. Open. Two, raised to the five mod 35 equals 32 sensors 32. To decrypt something, you do the opposite. So now that you have your cipher text is 32, you take plaintext message equals 32, raised to the five, BAD 35. And when you do this, you should get the answer two out of it by to decrypt that to the same plain text message. So that's RSA. Again. Rsa issues to large values, P equals five and q. In this case, you take that you calculate N and phi. After you do that, you choose a value E. F do choose. You could choose a value d. After they calculate that your public key is n e, n d. We'll do another example here. So for this, we're going to try it on yourself and do it together. This one should be a little bit simpler. To choose prime numbers, p equals three, Q equals five, right? So n becomes three times five is 15, and B becomes two times 48. Now I have to choose e. So I tried to choose e here. So can divide. So e has the values like e must be less than phi n e, and phi must be relatively prime. To know 23. Yes, for no five, yes, six, no, seven. Yes. So here all the values of a0. And on an exam, I can say choose one or two, choose the other ones. In this time. In this case, I'm gonna choose e equals seven, which equals seven. Only to make better spell, I choose e, right? N, choose d such that d mod phi equals one. So I have a D. So it's 70, BAD phi eight, it goes one. So what's d? D equal seven? What's the here? You Todd, our d plus one equals two, three. What would it be? So I can do the reverse. If you have any experience of this, a c 8162435714, twenty one twenty eight thirty five thirty five, twenty four. Thirty five, twenty four. So if D goes five, that's 7735 by eight, which is one. So d equals five for this case, I just did it using trial and error. I essentially just try D equals 1234. 52. I got it. Right. But why does, why does RSA work? Rsa works because once you calculate phi, you can't forgot where it is very easily, right? It's just really, really hard to do it. You essentially can't do it unless you do it by trial and error. So essentially, it's very, very hard to do the RSA. It's that it's just really slow even today. It's really slow. If you try to encrypt like a one megabyte file, it could take about one minute, even today's hardware on a computer. So essentially RSA is really not used anymore because space is not used for encrypting files directly. Typically RSA is used for encrypting like a key, that key. And then the AS key is used for encrypting the actual file because AES is really fast, while RSA is very, very slow. The last topic that we're talking about is session keys. Session keys is a way for me and you to exchange keys with each other without meeting with each other to create a session key reached with u and b. And this is a way that, let's say, I want to send a message to you. We need some sort of key. But I know that anyone watching us would be able to generate a key as well. Figured out the key, session keys is a way to generate keys that anyone watching us, we will not be able to forgot what our secret key s. And here's how it works. It's hard work. One person chooses a secret a, by Alice chooses a secret a, and Bob chooses a secret, be bout key and a public values. Public them if everyone knows it. While a secret, a secret. So again, a here is small a secret. Small b here is secret. G and n are public values. So then from here, January capital a and capital a is generated from g raised to a mod N. Alice will send g, g, N and capital a over to Bob. Asd reliefs Alice, capital a over to Bob. Bob generates the secret, be, write his own B. And Bob will calculate b equals g to the b mod N. Bob Wooster and low capital B back to Alice. And Alice can use that to generate capital K. K equals b raised to the a mod N. And Bob would generate k equals a to the b mod N. And at the end of the day, this k on this side is equal to the k on that side. So we somehow are able to generate a secret key k, and without ever meeting each other. So let's take an example. Let us take an example. The next one, I'm hasn't absolute numbers. And I want you to generate these numbers to calculate the values. We get the same values and feel free to cheat a little Bayesian wolframalpha D2. Well, here's an example, a 65315. Right? So here's ours. A change, a secret, a. So a secret a set six. It generates a public G. And here they choose five, and January is a public, and here's 23. All these numbers too big to do manually. Then Alice calculates a capital a equals five, raised to six by 23. Alright? This is something that you can do by yourself. And then ask for some G and an a over to Bob. So g is five, n is o, three and a is what? So what is a? Why is Scott what there is to this one time here? So five raised to the sixth method3. Five mod 23 equals 55 squared mod 23, it goes 25 bar 23, it goes to five, raised to four by three. It goes for January. I'm trying to generate 55656. Thirty-five raised six mod 23 goes two times 823 and that equals eight. Alright, so this is 88 goes from January, all these values over. Bob calculates a secret, lowercase b, that's 15. Bob has this value, so now Bob generates capital P, capital B, it goes five raised to d 1520 degree. Right? So now what? 51523 as we continue over here. So let's do what? Firebase, Firebase to bar 23. That equals 6423. That goes forward. He say a team that's equals 18, right? And now I will do five raised to the three bar 23, and that equals ten mod 23 equals ten. And I have five raised 15 bar 20. A3 equals one, a the B203. And that it goes, I don't know what the ego's retarded figured out. What's 23 times five times five equals five, right? So that's not the 23 times six E goes. 138, started 23 times x3 times eight equals it was 160 plus 241 ADI, overshot. So 20 times seven equals one sixty one. Sixty one. Twenty one forty one sixty one. Sixty one. That's 1919. I think that right. Well, we're not an exam. This is kind of tough, right? So let me double-check on the Wolfram Alpha over here. Four from alpha one. So I do five raised 55, raised at 15 bar 23 is 19. So I got that right. Oh, good. Right. So B is 19. So then Bob sends b back to Alice. Now, our database key k, k equals nine, t raise to d six mod 23. And barb on this side. As K goes, eight raised to the fifth teen mod 23. And these values should be exactly the same, right? So in the interest of time, I would just use Wolfram Alpha to check my answers here. So let's see. So it's, what is it? 19 raised, six, raised to the six mod 23. That's two. Okay? And now I have eight raised 15 mod 23, and that's two. So therefore, I got my answer to o. In other words, in this case, k equals k equals to both Alice and Bob were able to generate the same key. Wow, they have a secret, a, secret B on this side. And finally, we have the answer, or the answer is right here anyways. So that's Diffie-Hellman. Diffie-hellman is a very interesting property which we can january session keys between me and you, else Bob, without be the shutter and anyone viewing the data, just feeling not changing. And what will be the data is able to, not able to generate a key k from it. Thank you for this lecture. After this lecture, you should move on and do the homework assignment associated with this. Thank you very much and have a great day. Thank you. Bye."